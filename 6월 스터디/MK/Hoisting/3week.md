## 호이스팅 개념

"한마디로 그대로 끌어 올린다는 뜻!

—> 아래에 할당되어있는 변수나 함수를 호출!

# var vs. let vs. const

ES5 : var 은 함수 스코프

ES6 : let , const 은 블록 스코프

### 함수 레벨 스코프(Function-level scope)

함수 내에서 선언된 변수는 함수 내에서만 유효하고 함수 외부에서는 참조할 수 없다.

즉, 함수 내부에서 선언된 변수는 지역변수이며

     함수 외부 선언된 변수는 모두 전역변수이다

### 블록 레벨 스코프(Block-level scope)

모든 코드 블록 (함수, ifans ,for문 , while문 , try/catch문등)내에서 선언된 변수는 코드 블록내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.

즉, 코드 블록내부에서 선언한 변수는 지역변수이다.

### var 와 let 의 차이점

var 키워드 같은 경우는 동일한 이름을 갖는 변수를 중복해서 선언가능.

## But,

let 키워드로는 동일한 이름을 갖는 변수를 중복해서 선언 할수 없다, 변수를 중복 선언하면 문법 에러가 발생

```jsx
var drink = '코카콜라';
var drink = '펩시'; //중복 선언 허용

let snack = '새우깡';
let snack = '감자깡'; //Uncaught SyntaxError
```

### 호이스팅

자바스크립트에 ES6에서 도입된 let.const를 포함하여

모든선언(var, let, function , function\* , class) 을 호이스팅한다.

**호이스팅(Hoisting) 이란?**

var선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴것 처럼 동작하는 특성을 말한다

var 키워드로 선언된 변수와 달리 let키워드로 선언된 변수를 선언문 이전에 참조하면 참조에러가 발생한다.

이는 let 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문이다.

```jsx
console.log(drink); //undefined
var drink;

console.log(snack); //Error : bar is not defined
let snack;
```

### **1.선언 단계 (Declaration phase)**

변수를 실행 컨텍스트의 변수객체 에 등록한다.

이 변수 객체는 스코프가 참조하는 대상이 된다.

### 2.초기화 단계 (Initialization phase)

변수 객체에 등록된 변수를 위한 공간을 메모리에 확보한다.

이단계에서 변수는 undefined 로 초기화된다.

### 3.할당 단계 (Assignment phase)

undefined 로 초기화된 변수에 실제 값을 할당한다.

# var

var 키워드로 선언된 변수는 선언단계와 초기화단계가 한번에 이루어진다.

즉, 스코프에 변수를 등록하고(1.선언단계) 메모리에 변수를 위한 공간을 확보한 후 ,undefined 로 초기화 한다. (2.초기화단계)

따라서 변수 선언문이전에 변수에 접근해서 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined 를 반환한다.

이후 변수 할당문에 도달하면 비로소 값이 할당된다.(3.할당단계)

이러한 현상을 변수 호이스팅(Variable Hoisting)이라 한다

```jsx
//스코프의 선두에서 선언단계와 초기화 단계가 실행
//따라서 변수 선언문 이전에 변수를 참조할 수 있다.

console.log(drink); //undefined

var drink;
console.log(drink); //undefined

drink = '사이다'; //할당문에서 할당 단계가 실행된다.
console.log(drink); //'사이다'
```

# let

let 키워드로 선언된 변수는 선언단계와 초기화 단계가 분리되어이 진행된다.

즉, 스코프에 변수를 등록하지만 초기화단계는 변수 선언문에 도달했을때 이루어진다.초기화 이전에 변수에 접근하려고 하면 참조 에러 발생.

왜냐면 변수가 아직 초기화되지 않았기 때문에, 다시말하면 변수를 위한 메모리공간이 아직 확보되지 않았기 때문에

so, 스코프의 시작지점부터 초기화 시작지점까지는 변수를 참조 할 수없다.

스코프의 시작 지점부터 초기화 시작 지점까지의 구간을

'일시적 사각지대 (Temporal Dead Zone; TDZ)'라고 부름

```jsx
//스코프의 선두에서 선언단계가 실행된다.
//아직 변수가 초기화 (메모리 공간 확보와 undefined 로 초기화)되지 않았다.
//따라서 변수 선언문 이전에 변수는 참조 할수없음
console.log(drink); //ReferenceError

let drink; //변수 선언문에서 초기화단계 실행
console.log(drink); //undefined

drink = '사이다'; //할당문에서 할당단계 실행
console.log(drink);
```

- **함수표현식에서의 호이스팅**

  ***

  ## 함수 표현식 권장이유?

  자스의 쌤으로 알려진 **더글러스 크락포드는**

  함수생성에 있어서 **함수표현식만으로** 사용할 것을 권장

  ### Why?

  1.일단 함수선언식 예제

  ```jsx
  //1.sum(8,2)
  console.log(sum(8, 2)); //10

  //2. sum(yes,no)
  function sum(yes, no) {
    return yes + no;
  }
  //3.sum(4,5)
  console.log(sum(4, 5)); //9
  ```

  예제 1번은 아직 자기가 add() 함수에 정의 되지 않았지만

  add() 함수를 호출하는 것이 가능!

  왜냐면?

  함수가 자신이 위치한 코드에 상관없이 함수 선언문형태로 정의한 함수의 유효범위가

  코드의 맨처음부터 시작한다는것을 알수 있다!

  이것을 바로 함수 호이스팅이라 부른다.

  ## 결론

  함수를 선언하기 전에 함수를 선언한 것이기 때문에

  코드의 구조를 엉성하게 만들수도 있기에 더글라스 아저씨는 지적했다!

  ### so, 함수 표현식만을 사용하라고 권장함

  2.함수표현식 예제

  ```jsx
  //1.sum(8,2)
  console.log(sum(8, 2)); //Error

  //함수 표현식 형태로 sum() 함수 정의

  var sum = function (yes, no) {
    return yes + no;
  };

  //2.sum(5,4)
  console.log(5, 4); //9
  ```

  예제1번 함수는 함수표현식에서 실행이 될까? 답은 아니다!

  왜냐면?

  우리가 함수표현식 형태로 sum() 함수를 정의해줬기 때문에!

  so, 호이스팅을 일어나지 않는다!

  예제2번 함수를 보면 sum ()함수가 생성된 이후에 호출이 가능한것 알수있음!

  ## 결론

  함수표현식 형태는 정의해준 함수 생성된 후에

  함수의기능이 제대로 동작하는것을 확인할수있다

  ### so, 함수 표현식을 사용해서 불필요한 작업을 줄이자!

  ***
